# FieldAgent 実装計画書 (シンプル版)

**日付:** 2025年7月23日
**作成者:** Gemini
**ステータス:** 計画 (更新版)

---

## 1. 基本方針

「AIエージェント構築のポイント」に基づき、**シンプルさ**と**段階的な拡張**を最優先する。
最初のステップとして、**圃場情報のみに特化した**専門エージェント `FieldAgent` を実装する。

### 1.1. ユーザー体験の向上
- AIが生成したタスクプラン（実行計画）をLINEでユーザーに送信し、処理の透明性を確保する。
- まずはローカルファイルシステムで計画を管理し、コンセプトを実証した後、マルチユーザー対応のためにMongoDBへ移行する。

---

## 2. FieldAgentの定義

### 2.1. 役割
- **圃場（畑やハウス）に関する情報の照会、ただその一点にのみ責任を持つ。**
- 作物、資材、タスク管理など、圃場情報以外のトピックは扱わない。

### 2.2. 所属ツール
- `FieldInfoTool` のみ。
- このエージェントは、自身の専門外の情報を扱うツールを持ってはならない。

---

## 3. アーキテクチャ概要

```
[ユーザー] -> [LINE] -> [MasterAgent (司令塔)] -> [FieldAgent (圃場の専門家)]
   ^                                |
   |                                |
   +---- (プラン共有) <-------------+
```

1.  **MasterAgent**: ユーザーの指示を解釈し、それが圃場に関する問い合わせである場合、`FieldAgent`への指示を含むタスクプランを作成する。
2.  **プラン共有**: 作成したプランの内容をLINEメッセージとしてユーザーに送信する。
3.  **タスク実行**: プランに基づき、`FieldAgent` をツールとして呼び出し、圃場情報の照会を実行させる。
4.  **結果報告**: `FieldAgent` からの結果をユーザーに報告する。

---

## 4. 実装ステップ

### ステップ1: 専門エージェントの置き場所作成 (完了)
- `src/agri_ai/agents/` ディレクトリを作成する。

### ステップ2: `FieldAgent` の実装 (1時間)
1.  **ファイル作成:** `src/agri_ai/agents/field_agent.py` を作成。
2.  **クラス定義:** `FieldAgent` クラスを定義する。
3.  **ツール設定:** `FieldInfoTool` のみを持つように初期化する。
4.  **エージェント化:** LangChainの `AgentExecutor` を使って、ツールを実行できるエージェントとして構成する。

### ステップ3: `MasterAgent` の準備 (1-2時間)
1.  **ファイルリネーム:** `src/agri_ai/core/agent.py` を `src/agri_ai/core/master_agent.py` にリネームする。
2.  **クラス名変更:** `AgriAIAgent` を `MasterAgent` に変更する。
3.  **プロンプト更新:** `MasterAgent` のシステムプロンプトを更新し、自身を「司令塔」として位置づけ、プランを作成し専門エージェントに指示を出す役割を明確にする。
4.  **`FieldAgent`呼び出しツールの追加:** `MasterAgent` が `FieldAgent` を呼び出すためのカスタムツールを追加する。

### ステップ4: LINEでのプラン共有機能の実装 (1時間)
1.  **プラン生成ロジック:** `MasterAgent` 内に、ユーザーの指示からMarkdown形式の簡易的なプランを生成するロジックを追加する。
2.  **LINE送り返し:** 生成したプラン文字列を、`MasterAgent` の最終的な応答の一部として返すように、`webhook.py` を修正する。

### ステップ5: 統合とテスト (1時間)
- ユーザーがLINEで「第1ハウスの状況を教えて」と入力した際に、以下の流れが正しく実行されるかを確認する。
  1. `MasterAgent` がプランを作成し、LINEに送信する。
  2. `MasterAgent` が `FieldAgent` を呼び出す。
  3. `FieldAgent` が `FieldInfoTool` を使って情報を取得する。
  4. 最終的な結果がユーザーに返される。

---

## 5. タイムライン

- **合計見積もり:** 3〜5時間

---

## 6. 今後の拡張案

- **会話履歴の記憶と活用:**
  - **目的:** ユーザーとの過去のやり取りを記憶し、文脈に応じた、より自然で賢い応答を実現する。
  - **実装案:**
    1. LINEの`user_id`に紐づけて、会話の履歴（ユーザーの発言、AIの応答）をMongoDBに保存する新しいコレクション (`conversation_history`) を作成する。
    2. MasterAgentがユーザーからのメッセージを受け取った際に、過去の会話履歴をDBから取得し、プロンプトに含める。
    3. これにより、「あれ」「それ」といった指示代名詞を理解したり、以前の会話の流れを汲んだ提案が可能になる。