"""
QueryAnalyzer: сЃдсЃ╝сѓХсЃ╝сѓ»сѓесЃфтѕєТъљсѓхсЃ╝сЃЊсѓ╣

MasterAgentсЂІсѓЅтѕЄсѓітЄ║сЂЌсЂЪсђЂсЃдсЃ╝сѓХсЃ╝сЂ«ТёЈтЏ│тѕєТъљсЂет«ЪУАїсЃЌсЃЕсЃ│ућЪТѕљсѓњТІЁтйЊсЂЎсѓІсѓхсЃ╝сЃЊсѓ╣сђѓ
тЇўСИђУ▓гС╗╗тјЪтЅЄсЂФтЪ║сЂЦсЂЇсђЂсѓ»сѓесЃфтѕєТъљсЂФуЅ╣тїќсЂЌсЂЪтЄдуљєсѓњТЈљСЙЏсЂЎсѓІсђѓ
"""

import re
import logging
from typing import Dict, Optional
from .field_name_extractor import FieldNameExtractor

logger = logging.getLogger(__name__)


class QueryAnalyzer:
    """сЃдсЃ╝сѓХсЃ╝сѓ»сѓесЃфсЂ«тѕєТъљсЃ╗ТёЈтЏ│уљєУДБсѓхсЃ╝сЃЊсѓ╣"""
    
    def __init__(self):
        self.field_name_extractor = FieldNameExtractor()
    
    async def analyze_query_intent(self, message: str) -> Dict[str, any]:
        """
        сЃдсЃ╝сѓХсЃ╝сѓ»сѓесЃфсѓњтѕєТъљсЂЌсђЂТёЈтЏ│сЂесЃЉсЃЕсЃАсЃ╝сѓ┐сѓњТійтЄ║
        
        Args:
            message: сЃдсЃ╝сѓХсЃ╝сЂ«сЃАсЃЃсѓ╗сЃ╝сѓИ
            
        Returns:
            {
                'intent': str,           # ТёЈтЏ│сѓ┐сѓцсЃЌ
                'agent': str,           # ТІЁтйЊсѓесЃ╝сѓИсѓДсЃ│сЃѕ
                'extracted_data': Dict, # ТійтЄ║сЂЋсѓїсЂЪсЃЄсЃ╝сѓ┐
                'confidence': float     # С┐Ажа╝т║д
            }
        """
        try:
            # тЪ║ТюгуџёсЂфТёЈтЏ│тѕєТъљ
            intent_result = self._analyze_basic_intent(message)
            
            # УЕ│у┤░сЃЄсЃ╝сѓ┐ТійтЄ║
            extracted_data = await self._extract_detailed_data(message, intent_result['intent'])
            
            return {
                'intent': intent_result['intent'],
                'agent': intent_result['agent'],
                'extracted_data': extracted_data,
                'confidence': intent_result['confidence'],
                'original_message': message
            }
            
        except Exception as e:
            logger.error(f"сѓ»сѓесЃфтѕєТъљсѓесЃЕсЃ╝: {e}")
            return {
                'intent': 'unknown',
                'agent': 'field_agent',  # сЃЄсЃЋсѓЕсЃФсЃѕ
                'extracted_data': {},
                'confidence': 0.0,
                'original_message': message,
                'error': str(e)
            }
    
    def _analyze_basic_intent(self, message: str) -> Dict[str, any]:
        """тЪ║ТюгуџёсЂфТёЈтЏ│тѕєТъљ"""
        
        # тюЃта┤уЎ╗жї▓у│╗
        if any(keyword in message for keyword in ["уЎ╗жї▓", "У┐йтіа", "Тќ░сЂЌсЂё", "СйюТѕљ"]) and \
           any(keyword in message for keyword in ["тюЃта┤", "сЃЈсѓдсѓ╣", "уЋЉ", "ућ░"]):
            return {
                'intent': 'field_registration',
                'agent': 'field_registration_agent',
                'confidence': 0.9
            }
        
        # тюЃта┤ТЃЁта▒у│╗
        if any(keyword in message for keyword in ["тюЃта┤", "сЃЈсѓдсѓ╣", "уЋЉ", "жЮбуЕЇ", "СйюС╗ўсЂЉ"]):
            return {
                'intent': 'field_info',
                'agent': 'field_agent',
                'confidence': 0.8
            }
        
        # сЂЮсЂ«С╗ќсЂ«сЃЉсѓ┐сЃ╝сЃ│сѓѓС╗ітЙїУ┐йтіаС║ѕт«џ
        
        # сЃЄсЃЋсѓЕсЃФсЃѕ: тюЃта┤ТЃЁта▒сЂесЂЌсЂдтЄдуљє
        return {
            'intent': 'field_info',
            'agent': 'field_agent',
            'confidence': 0.5
        }
    
    async def _extract_detailed_data(self, message: str, intent: str) -> Dict[str, any]:
        """ТёЈтЏ│сЂФт┐юсЂўсЂЪУЕ│у┤░сЃЄсЃ╝сѓ┐ТійтЄ║"""
        
        extracted = {}
        
        # тЁ▒жђџ: тюЃта┤тљЇТійтЄ║
        field_name = await self._extract_field_name(message)
        if field_name:
            extracted['field_name'] = field_name
        
        # ТёЈтЏ│тѕЦсЂ«УЕ│у┤░ТійтЄ║
        if intent == 'field_registration':
            extracted.update(self._extract_registration_data(message))
        elif intent == 'field_info':
            extracted.update(self._extract_info_query_data(message))
        
        return extracted
    
    def _extract_registration_data(self, message: str) -> Dict[str, any]:
        """тюЃта┤уЎ╗жї▓ућесЃЄсЃ╝сѓ┐ТійтЄ║"""
        data = {}
        
        # жЮбуЕЇТійтЄ║
        area = self._extract_area(message)
        if area:
            data['area'] = area
        
        # сѓесЃфсѓбтљЇТійтЄ║
        area_name = self._extract_area_name(message)
        if area_name:
            data['area_name'] = area_name
        
        return data
    
    def _extract_info_query_data(self, message: str) -> Dict[str, any]:
        """тюЃта┤ТЃЁта▒сѓ»сѓесЃфућесЃЄсЃ╝сѓ┐ТійтЄ║"""
        data = {}
        
        # сѓ»сѓесЃфсѓ┐сѓцсЃЌтѕцт«џ
        if "жЮбуЕЇ" in message:
            data['query_type'] = 'area'
        elif "СИђУдД" in message or "сЂЎсЂ╣сЂд" in message:
            data['query_type'] = 'list'
        elif "уіХТ│Ђ" in message or "УЕ│у┤░" in message:
            data['query_type'] = 'detail'
        else:
            data['query_type'] = 'general'
        
        return data
    
    async def create_execution_plan(self, analysis_result: Dict[str, any]) -> str:
        """
        тѕєТъљухљТъюсЂФтЪ║сЂЦсЂёсЂдт«ЪУАїсЃЌсЃЕсЃ│сѓњућЪТѕљ
        
        Args:
            analysis_result: analyze_query_intent()сЂ«ухљТъю
            
        Returns:
            т«ЪУАїсЃЌсЃЕсЃ│сЂ«сЃєсѓГсѓ╣сЃѕ
        """
        intent = analysis_result['intent']
        extracted_data = analysis_result['extracted_data']
        
        try:
            if intent == 'field_registration':
                return self._create_registration_plan(extracted_data)
            elif intent == 'field_info':
                return self._create_info_plan(extracted_data)
            else:
                return self._create_general_plan(analysis_result)
                
        except Exception as e:
            logger.error(f"т«ЪУАїсЃЌсЃЕсЃ│ућЪТѕљсѓесЃЕсЃ╝: {e}")
            return "­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│\n1. сЃдсЃ╝сѓХсЃ╝сЃфсѓ»сѓесѓ╣сЃѕсѓњтЄдуљє\n2. ухљТъюсѓњсЃгсЃЮсЃ╝сЃѕ"
    
    def _create_registration_plan(self, extracted_data: Dict[str, any]) -> str:
        """тюЃта┤уЎ╗жї▓ућесЃЌсЃЕсЃ│ућЪТѕљ"""
        field_name = extracted_data.get('field_name', 'Тќ░сЂЌсЂётюЃта┤')
        
        if field_name != 'Тќ░сЂЌсЂётюЃта┤':
            return f"""­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│
1. сђї{field_name}сђЇсѓњТќ░УдЈтюЃта┤сЂесЂЌсЂдуЎ╗жї▓тЄдуљє
2. жЮбуЕЇсЃ╗сѓесЃфсѓбТЃЁта▒сѓњтљФсѓЂсЂдсЃЄсЃ╝сѓ┐сЃЎсЃ╝сѓ╣сЂФС┐ЮтГў
3. уЎ╗жї▓т«їС║єжђџуЪЦсѓњсЃдсЃ╝сѓХсЃ╝сЂФжђЂС┐А"""
        else:
            return """­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│
1. тюЃта┤уЎ╗жї▓т░ѓжќђсѓесЃ╝сѓИсѓДсЃ│сЃѕ(FieldRegistrationAgent)сЂДТќ░сЂЌсЂётюЃта┤сѓњуЎ╗жї▓
2. уЎ╗жї▓ухљТъюсѓњуб║УфЇсЂЌсЂдсЃдсЃ╝сѓХсЃ╝сЂФта▒тЉі"""
    
    def _create_info_plan(self, extracted_data: Dict[str, any]) -> str:
        """тюЃта┤ТЃЁта▒сѓ»сѓесЃфућесЃЌсЃЕсЃ│ућЪТѕљ"""
        field_name = extracted_data.get('field_name', '')
        query_type = extracted_data.get('query_type', 'general')
        area_name = extracted_data.get('area_name', '')
        
        if field_name:
            if query_type == 'area':
                return f"""­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│
1. сђї{field_name}сђЇсЂ«жЮбуЕЇТЃЁта▒сѓњсЃфсѓхсЃ╝сЃЂ
2. ухљТъюсѓњhaтЇўСйЇсЂДсЃдсЃ╝сѓХсЃ╝сЂФсЃгсЃЮсЃ╝сЃѕ"""
            elif query_type == 'detail':
                return f"""­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│
1. сђї{field_name}сђЇсЂ«УЕ│у┤░ТЃЁта▒сѓњсЃфсѓхсЃ╝сЃЂ
2. жЮбуЕЇсЃ╗СйюС╗ўсЂЉсЃ╗СйюТЦГС║ѕт«џсѓњсЃдсЃ╝сѓХсЃ╝сЂФсЃгсЃЮсЃ╝сЃѕ"""
            else:
                return f"""­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│
1. сђї{field_name}сђЇсЂ«ТЃЁта▒сѓњсЃфсѓхсЃ╝сЃЂ
2. УЕ│у┤░сЃЄсЃ╝сѓ┐сѓњсЃдсЃ╝сѓХсЃ╝сЂФсЃгсЃЮсЃ╝сЃѕ"""
        elif query_type == 'list':
            if area_name:
                return f"""­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│
1. сђї{area_name}сђЇсЂ«тюЃта┤СИђУдДсѓњсЃфсѓхсЃ╝сЃЂ
2. тљётюЃта┤сЂ«жЮбуЕЇсЃ╗СйюС╗ўсЂЉуіХТ│ЂсѓњсЃдсЃ╝сѓХсЃ╝сЂФсЃгсЃЮсЃ╝сЃѕ"""
            else:
                return """­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│
1. тЁетюЃта┤сЂ«СИђУдДТЃЁта▒сѓњсЃфсѓхсЃ╝сЃЂ
2. жЮбуЕЇсЃ╗СйюС╗ўсЂЉуіХТ│ЂсѓњТЋ┤уљєсЂЌсЂдсЃдсЃ╝сѓХсЃ╝сЂФсЃгсЃЮсЃ╝сЃѕ"""
        else:
            return """­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│
1. тюЃта┤ТЃЁта▒сѓњт░ѓжќђсѓесЃ╝сѓИсѓДсЃ│сЃѕ(FieldAgent)сЂДУф┐ТЪ╗
2. ухљТъюсѓњсѓЈсЂІсѓісѓёсЂЎсЂЈТЋ┤уљєсЂЌсЂдта▒тЉі"""
    
    def _create_general_plan(self, analysis_result: Dict[str, any]) -> str:
        """Т▒јућесЃЌсЃЕсЃ│ућЪТѕљ"""
        query_type = self._analyze_query_type(analysis_result['original_message'])
        return f"""­ЪЊІ т«ЪУАїсЃЌсЃЕсЃ│
1. сђї{query_type}сђЇсЂФсЂцсЂёсЂдТюђжЂЕсЂфсЃёсЃ╝сЃФсЂДТЃЁта▒тЈјжЏє
2. ухљТъюсѓњТЋ┤уљєсЂЌсЂдсЃдсЃ╝сѓХсЃ╝сЂФсЃгсЃЮсЃ╝сЃѕ"""
    
    async def _extract_field_name(self, message: str) -> str:
        """сЃАсЃЃсѓ╗сЃ╝сѓИсЂІсѓЅтюЃта┤тљЇсѓњтІЋуџёсЂФТійтЄ║"""
        try:
            result = await self.field_name_extractor.extract_field_name(message)
            
            # С┐Ажа╝т║дсЂї50%С╗ЦСИісЂ«та┤тљѕсЂ«сЂ┐ТјАуће
            if result['confidence'] >= 0.5:
                logger.info(f"тІЋуџётюЃта┤тљЇТійтЄ║ТѕљтіЪ: {result['field_name']} (С┐Ажа╝т║д: {result['confidence']:.2f})")
                return result['field_name']
            else:
                logger.info(f"тІЋуџётюЃта┤тљЇТійтЄ║: С┐Ажа╝т║дСИЇУХ│ ({result['confidence']:.2f})")
                return ""
                
        except Exception as e:
            logger.error(f"тІЋуџётюЃта┤тљЇТійтЄ║сѓесЃЕсЃ╝: {e}")
            # сЃЋсѓЕсЃ╝сЃФсЃљсЃЃсѓ»: тЙЊТЮЦсЂ«ТГБУдЈУАеуЈЙТќ╣т╝Ј
            return self._extract_field_name_fallback(message)
    
    def _extract_field_name_fallback(self, message: str) -> str:
        """сЃЋсѓЕсЃ╝сЃФсЃљсЃЃсѓ»ућесЂ«тЙЊТЮЦтюЃта┤тљЇТійтЄ║"""
        # Тћ╣УЅ»сЂЋсѓїсЂЪТГБУдЈУАеуЈЙсЃЉсѓ┐сЃ╝сЃ│
        field_patterns = [
            r'сђї([^сђЇ]+)сђЇ',           # сђїтюЃта┤тљЇсђЇ
            r'([^сЂ«сѓњ\s]{2,})сЂ«(?:жЮбуЕЇ|ТЃЁта▒|УЕ│у┤░|уіХТ│Ђ)',  # 2ТќЄтГЌС╗ЦСИісЂ«тюЃта┤тљЇ
            r'([^сЂ«сѓњ\s]{2,})сѓњ(?:уЎ╗жї▓|У┐йтіа)',         # 2ТќЄтГЌС╗ЦСИісЂ«тюЃта┤тљЇ
            r'([^сЂ«сѓњ\s]{2,})сЂ»(?:сЂЕсЂЊ|СйЋ)',           # 2ТќЄтГЌС╗ЦСИісЂ«тюЃта┤тљЇ
        ]
        
        for pattern in field_patterns:
            match = re.search(pattern, message)
            if match:
                extracted = match.group(1)
                if len(extracted) >= 2:  # Тюђт░ЈжЋисЃЂсѓДсЃЃсѓ»
                    return extracted
        
        return ""
    
    def _extract_area(self, message: str) -> Optional[str]:
        """жЮбуЕЇТЃЁта▒сѓњТійтЄ║"""
        area_patterns = [
            r'(\d+\.?\d*)\s*ha',
            r'(\d+\.?\d*)\s*сЃўсѓ»сѓ┐сЃ╝сЃФ',
            r'(\d+\.?\d*)\s*сјА',
            r'(\d+\.?\d*)\s*т╣│Тќ╣сЃАсЃ╝сЃѕсЃФ',
        ]
        
        for pattern in area_patterns:
            match = re.search(pattern, message)
            if match:
                return match.group(0)
        
        return None
    
    def _extract_area_name(self, message: str) -> str:
        """сЃАсЃЃсѓ╗сЃ╝сѓИсЂІсѓЅсѓесЃфсѓбтљЇсѓњТійтЄ║"""
        if "У▒іу│а" in message:
            return "У▒іу│асѓесЃфсѓб"
        elif "У▒іуиЉ" in message:
            return "У▒іуиЉсѓесЃфсѓб"
        return ""
    
    def _extract_material_name(self, message: str) -> str:
        """сЃАсЃЃсѓ╗сЃ╝сѓИсЂІсѓЅУ│ЄТЮљтљЇсѓњТійтЄ║"""
        # У│ЄТЮљтљЇсЂ«сЃЉсѓ┐сЃ╝сЃ│
        material_patterns = [
            r'сђї([^сђЇ]+)сђЇ',  # сђїУЙ▓УќгтљЇсђЇ
            r'([^сЂ«\s]+)сЂ«тИїжЄѕ',  # УЙ▓УќгтљЇсЂ«тИїжЄѕ
            r'([^сѓњ\s]+)сѓњ',     # УЙ▓УќгтљЇсѓњ
        ]
        
        for pattern in material_patterns:
            match = re.search(pattern, message)
            if match:
                return match.group(1)
        
        return ""
    
    def _analyze_query_type(self, message: str) -> str:
        """сѓ»сѓесЃфсѓ┐сѓцсЃЌсѓњтѕєТъљ"""
        if any(keyword in message for keyword in ["тцЕТ░Ќ", "Т░ЌТИЕ", "жЏе"]):
            return "тцЕТ░ЌТЃЁта▒"
        elif any(keyword in message for keyword in ["уЌЁТ░Ќ", "т«│УЎФ", "уЌЄуіХ"]):
            return "уЌЁт«│УЎФУе║ТќГ"
        elif any(keyword in message for keyword in ["тЈјуЕФ", "тЄ║УЇи", "У▓ЕтБ▓"]):
            return "тЈјуЕФсЃ╗тЄ║УЇиТЃЁта▒"
        else:
            return "УЙ▓ТЦГтЁеУѕгсЂ«тЋЈсЂётљѕсѓЈсЂЏ"