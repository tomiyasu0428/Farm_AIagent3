# 2025-07-26 ツールリファクタリング案

## 概要
現在のツール（`AgriAIBaseTool`およびそれを継承するツール）の同期・非同期実行に関する設計は、複雑でデバッグが困難な側面があります。特に、`AgriAIBaseTool`の `_run` メソッド内で非同期の `_arun` を無理やり同期的に呼び出すために、新しいスレッドとイベントループを作成している点が複雑さの主な原因です。

このドキュメントでは、よりシンプルで堅牢なツール設計へのリファクタリング案を提案します。

## 現状の問題点
*   `AgriAIBaseTool._run` メソッドが、非同期メソッド (`_arun`) を同期的に呼び出すために、スレッドとイベントループの複雑な管理を行っている。
*   これにより、コードの可読性が低下し、デバッグが困難になっている。
*   パフォーマンスオーバーヘッドが発生する可能性がある。
*   LangChainのツール呼び出しにおける `query` 引数の扱いが、同期・非同期メソッド間で一貫性を保つために複雑な対応が必要となる。

## リファクタリング案

### 基本方針
ツールごとに同期 (`_run`) と非同期 (`_arun`) の実装を明確に分け、`_run` の中で `_arun` を呼び出すような複雑なロジックは排除します。

### 1. `src/agri_ai/langchain_tools/base_tool.py` の修正
`AgriAIBaseTool` の `_run` メソッドを、具体的な実装を持たない抽象メソッドに戻します。これにより、基底クラスはインターフェースの定義に専念し、具体的な実行ロジックは各ツールクラスに委譲されます。

**変更前 (`AgriAIBaseTool`):**
```python
class AgriAIBaseTool(BaseTool, ABC):
    # ...
    def _run(self, query: str = "", **kwargs: Any) -> Any:
        # 複雑なスレッドとイベントループの管理ロジック
        # ...
    async def _arun(self, query: str, **kwargs: Any) -> Any:
        # ...
```

**変更後 (`AgriAIBaseTool`):**
```python
class AgriAIBaseTool(BaseTool, ABC):
    # ...
    @abstractmethod
    def _run(self, query: str = "", **kwargs: Any) -> Any:
        """同期的にツールを実行する抽象メソッド"""
        pass

    @abstractmethod
    async def _arun(self, query: str, **kwargs: Any) -> Any:
        """非同期にツールを実行する抽象メソッド"""
        pass
    # ...
```

### 2. 各ツールクラス（例: `src/agri_ai/langchain_tools/work_log_registration_agent_tool.py`）の修正
各ツールクラスで、`_run` メソッドを独自に実装します。非同期処理が必要な場合は、`asyncio.run()` を使用して非同期メソッドを同期的に呼び出します。

**変更前 (`WorkLogRegistrationAgentTool`):**
（`_run` は `AgriAIBaseTool` の実装に依存）

**変更後 (`WorkLogRegistrationAgentTool` の例):**
```python
class WorkLogRegistrationAgentTool(AgriAIBaseTool):
    # ...
    async def _arun(self, query: str = "", **kwargs) -> str:
        """非同期実行"""
        message = kwargs.get('message', query)
        user_id = kwargs.get('user_id', 'unknown_user')
        return await self._execute_work_log_registration(message=message, user_id=user_id)

    def _run(self, query: str = "", **kwargs) -> str:
        """同期実行"""
        import asyncio # ここでインポート
        message = kwargs.get('message', query)
        user_id = kwargs.get('user_id', 'unknown_user')
        
        # asyncio.run() を使って非同期メソッドを同期的に呼び出す
        return asyncio.run(self._execute_work_log_registration(message=message, user_id=user_id))

    async def _execute_work_log_registration(self, message: str, user_id: str) -> str:
        # ... (実際のロジック) ...
```

## 期待される効果
*   **コードの簡素化**: 複雑なスレッドとイベントループの管理ロジックが不要になり、コードが読みやすくなります。
*   **責務の明確化**: 基底クラスはインターフェースを定義し、具体的な実装は各ツールクラスが担当することで、責務が分離されます。
*   **デバッグの容易化**: 同期・非同期の処理の流れが追いやすくなり、問題の特定と解決が容易になります。
*   **パフォーマンスの改善**: 不要なスレッド生成やイベントループの管理オーバーヘッドが削減される可能性があります。

このリファクタリングは、システムの安定性と保守性を高める上で重要であると考えられます。