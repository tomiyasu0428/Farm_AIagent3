# 農業AIエージェント アーキテクチャ完全ガイド

## 📋 概要

**作成日**: 2025年7月26日  
**対象**: 農業管理AIエージェントシステム  
**技術スタック**: LangChain/LangGraph + MongoDB + Google Cloud  
**目的**: Manusを参考にしたマルチエージェントシステム設計と実装ガイド

---

## 🎯 第1部: アーキテクチャ設計思想

### 1.1 Manusから学ぶエージェント設計の原則

先進的なAIエージェントプラットフォーム「Manus」の分析から得られた核心的な設計原則：

#### **オーケストレーター・パラダイム**
- **単一LLM依存の脱却**: 複数のモデルとツールを協調させる「指揮者」としての役割
- **マルチエージェントシステム**: 責務分割による専門性と保守性の向上
- **モデル非依存アーキテクチャ**: 将来のモデル変更に対応可能な柔軟性

#### **5つの核心技術**

##### 1. KV-Cache最適化
```
プロンプト構造の「聖域化」
├─ システムプロンプトの完全固定化
├─ 追記専用コンテキスト設計
└─ 戦略的キャッシュブレークポイント配置
```

##### 2. 賢いツール管理
```
削除ではなくマスキング
├─ ステートマシンによる可視性制御
├─ 戦略的ツール命名（プレフィックス活用）
└─ レスポンスプリフィル技術
```

##### 3. ファイルシステム活用
```
無限の外部メモリ
├─ todo.md による計画管理
├─ 永続的なセッション間データ維持
└─ AIが直接読み書き可能な構造化情報
```

##### 4. リサイテーション（復唱）技術
```
注意操作による集中力向上
├─ 重要情報の意図的な繰り返し参照
├─ タスクの優先順位明確化
└─ 長期的一貫性の維持
```

##### 5. 実践的開発アプローチ
```
確率的勾配降下法
├─ 仮説→実装→検証の高速サイクル
├─ 段階的複雑性管理
└─ 小さな改善の積み重ね
```

### 1.2 農業特化への適用戦略

#### **単一エージェントの限界**
- **ツール選択問題**: 11個のツールによる認知負荷
- **幻覚リスク**: 存在しないツール引数の生成
- **パフォーマンス低下**: 推論時間の増大

#### **マルチエージェント解決策**
```
責務分割による専門化
├─ TaskManagementAgent: タスク操作専門
├─ AgronomyAdvisorAgent: 農業助言専門
├─ FarmDataQueryAgent: データ照会専門
└─ NotificationAgent: 通知管理専門
```

---

## 🏗️ 第2部: LangGraphマルチエージェントアーキテクチャ

### 2.1 スーパーバイザー・ワーカーパターン

#### **アーキテクチャ概要**
```
LineSupervisor (中央統制)
├─ LINEメッセージ受信・解釈
├─ タスクルーティング判断
├─ 最終応答整形
└─ 状態管理・調整

↓ 条件分岐エッジ

ワーカーエージェント群
├─ TaskManagementAgent
├─ AgronomyAdvisorAgent  
├─ FarmDataQueryAgent
└─ NotificationAgent
```

#### **詳細エージェント設計**

| エージェント | 主要責務 | 主要ツール | 実装ポイント |
|-------------|---------|------------|------------|
| **LineSupervisor** | メッセージ解釈・ルーティング・統合 | なし（他エージェントがツール） | 関数呼び出しによる確実なルーティング |
| **TaskManagementAgent** | タスクCRUD操作全般 | TaskLookup, TaskUpdate, TaskCreate | 高速レスポンス重視 |
| **AgronomyAdvisorAgent** | 農薬・肥料・天候分析 | CropMaterial, MaterialDilution, Weather | 複雑な判断ロジック実装 |
| **FarmDataQueryAgent** | 農場データ照会 | FieldInfo, SensorData, WorkerLog | 最適化されたクエリ生成 |
| **NotificationAgent** | アウトバウンド通信 | Notification | シンプルなユーティリティ |

### 2.2 中央状態管理システム

#### **AgriAgentState 定義**
```python
from typing import TypedDict, Annotated, List, Dict, Any
from langchain_core.messages import BaseMessage
import operator

class AgriAgentState(TypedDict):
    # 会話履歴（追加モード）
    messages: Annotated[List[BaseMessage], operator.add]
    
    # ルーティング制御
    next_agent: str
    
    # ユーザー情報
    user_id: str
    thread_id: str
    
    # Manus式タスク計画（todo.md模倣）
    task_plan: Dict[str, Any]
    
    # デバッグ・分析用
    intermediate_steps: Annotated[List[Dict], operator.add]
    
    # 最終レスポンス
    final_response: str
```

#### **MongoDBSaver連携**
```python
from langgraph.checkpoint.mongodb import MongoDBSaver

# 永続化チェックポインター
checkpointer = MongoDBSaver(
    connection_string="mongodb://...",
    database_name="agri_ai_checkpoints"
)

# グラフコンパイル時に指定
app = workflow.compile(checkpointer=checkpointer)
```

### 2.3 LineSupervisorの実装

#### **プロンプトエンジニアリング**
```python
supervisor_system_prompt = """
あなたは以下のワーカーからなるチームを管理するスーパーバイザーです: {members}

各ワーカーの専門分野:
- TaskManagementAgent: 農作業タスクの作成・更新・照会
- AgronomyAdvisorAgent: 農薬・肥料・天候に基づく専門的助言
- FarmDataQueryAgent: 圃場・センサー・作業履歴の一般的データ照会
- NotificationAgent: ユーザーへの通知・アラート送信

会話履歴を考慮し、次にどの役割を呼び出すべきかを判断してください。
すべてのタスクが完了した場合は 'FINISH' を選択してください。
"""
```

#### **関数呼び出しによるルーティング**
```python
from langchain_core.pydantic_v1 import BaseModel, Field
from typing import Literal

AgentName = Literal[
    "TaskManagementAgent", 
    "AgronomyAdvisorAgent", 
    "FarmDataQueryAgent", 
    "NotificationAgent", 
    "FINISH"
]

class Route(BaseModel):
    """次に呼び出すべきワーカーまたは完了を選択"""
    next: AgentName = Field(
        description="タスクを処理する次のエージェント名、または'FINISH'"
    )

# LLMチェーン
supervisor_chain = (
    prompt.partial(members=", ".join(members))
    | llm.with_structured_output(Route)
)
```

### 2.4 ワーカーエージェントの実装

#### **create_react_agentの活用**
```python
from langgraph.prebuilt import create_react_agent

# TaskManagementAgent例
task_management_tools = [task_update_tool, task_lookup_tool, task_create_tool]

task_management_agent = create_react_agent(
    llm,
    tools=task_management_tools,
    messages_modifier="あなたはタスク管理の専門家です。"
)

# エージェントをツール化
def create_agent_tool(agent_executor, name: str, description: str):
    def agent_as_tool(input_dict: dict):
        return agent_executor.invoke(input_dict)
    
    return Tool(name=name, func=agent_as_tool, description=description)
```

#### **高度なPesticideRecommendationTool**
```python
# サブグラフとしての実装
class PesticideRecommendationTool:
    async def recommend(self, field_id: str, crop_id: str) -> Dict:
        # Step 1: データ収集
        field_info = await self.field_info_tool(field_id)
        work_history = await self.work_records_lookup(field_id)
        weather = await self.weather_forecast_tool()
        available_materials = await self.crop_material_tool(crop_id)
        
        # Step 2: ロジック統合
        candidates = self._filter_by_rotation_rules(
            available_materials, work_history
        )
        ranked = self._rank_by_weather_conditions(candidates, weather)
        
        # Step 3: 構造化レスポンス
        return {
            "recommended_material": ranked[0]["name"],
            "dilution_ratio": ranked[0]["dilution"],
            "reasoning": self._generate_reasoning(ranked[0], field_info)
        }
```

---

## 🔧 第3部: 高度な実装パターン

### 3.1 Manus式「反復」パターンの実装

#### **scratchpadコレクション設計**
```javascript
// MongoDB scratchpad コレクション
{
  "_id": ObjectId("..."),
  "thread_id": "user_12345_session_001",
  "task_type": "weekly_planning",
  "plan": {
    "goal": "全圃場の週間作業計画を立てる",
    "steps": [
      {"id": 1, "description": "A畑の分析", "status": "completed"},
      {"id": 2, "description": "B畑の分析", "status": "in_progress"},
      {"id": 3, "description": "リソース統合", "status": "pending"}
    ]
  },
  "created_at": ISODate("..."),
  "updated_at": ISODate("...")
}
```

#### **計画管理フロー**
```python
class TaskPlanManager:
    async def create_plan(self, thread_id: str, goal: str, steps: List[str]):
        plan_doc = {
            "thread_id": thread_id,
            "task_type": self._classify_task(goal),
            "plan": {
                "goal": goal,
                "steps": [
                    {"id": i+1, "description": step, "status": "pending"}
                    for i, step in enumerate(steps)
                ]
            },
            "created_at": datetime.now()
        }
        result = await self.collection.insert_one(plan_doc)
        return str(result.inserted_id)
    
    async def update_progress(self, plan_id: str, step_id: int, status: str):
        await self.collection.update_one(
            {"_id": ObjectId(plan_id), "plan.steps.id": step_id},
            {"$set": {"plan.steps.$.status": status, "updated_at": datetime.now()}}
        )
    
    async def inject_into_prompt(self, plan_id: str) -> str:
        plan = await self.collection.find_one({"_id": ObjectId(plan_id)})
        return f"""
現在のタスク計画:
目標: {plan['plan']['goal']}
進捗: {self._format_progress(plan['plan']['steps'])}

この計画に従って次のステップを実行してください。
"""
```

### 3.2 自己修正とエラーハンドリング

#### **ツールのtry-except包装**
```python
@tool
async def safe_task_lookup(query: str) -> str:
    """安全なタスク検索ツール"""
    try:
        # 実際のデータベース処理
        results = await db.tasks.find({"description": {"$regex": query}})
        return format_results(results)
    
    except Exception as e:
        # エラーを構造化情報として返す
        return f"ERROR: データベースクエリが失敗しました。詳細: {str(e)}\n" \
               f"実行したクエリ: {query}\n" \
               f"修正案: クエリの構文を確認してください。"
```

#### **自己修正ループの実装**
```python
def create_error_recovery_edge(state: AgriAgentState):
    """エラー回復のための条件分岐"""
    last_message = state["messages"][-1]
    
    if isinstance(last_message, ToolMessage):
        if last_message.content.startswith("ERROR:"):
            return "retry_agent"  # 修正試行エージェントへ
    
    return "continue"  # 通常フロー継続

# グラフへの追加
workflow.add_conditional_edges(
    "data_query_agent",
    create_error_recovery_edge,
    {
        "retry_agent": "data_query_agent_retry",
        "continue": "supervisor"
    }
)
```

### 3.3 非同期タスクとスケーラビリティ

#### **Google Cloud アーキテクチャ**
```
LINE Webhook
↓ (即座のレスポンス)
Cloud Functions (軽量認証)
↓
Cloud Run (同期処理)
├─ 高速クエリ → 即座に応答
└─ 長時間タスク → Pub/Sub投入
    ↓
Cloud Run (バックグラウンドワーカー)
├─ LangGraphエージェント実行
└─ NotificationTool経由でLINE通知
```

#### **非同期実装パターン**
```python
import asyncio
from google.cloud import pubsub_v1

class AsyncTaskManager:
    async def handle_request(self, message: str, user_id: str):
        # タスクの複雑度判定
        if self._is_complex_task(message):
            # 即座に受領確認
            await self._send_acknowledgment(user_id)
            
            # バックグラウンドタスクとして投入
            await self._enqueue_background_task({
                "message": message,
                "user_id": user_id,
                "task_type": "complex_planning"
            })
        else:
            # 同期的に処理
            return await self._process_immediately(message, user_id)
    
    async def _enqueue_background_task(self, task_data: Dict):
        publisher = pubsub_v1.PublisherClient()
        topic_path = publisher.topic_path(PROJECT_ID, TOPIC_NAME)
        
        message_bytes = json.dumps(task_data).encode("utf-8")
        future = publisher.publish(topic_path, message_bytes)
        await asyncio.wrap_future(future)
```

---

## 📊 第4部: データ整合性と並行性制御

### 4.1 レースコンディション対策

#### **オプティミスティックロック実装**
```python
async def update_task_with_optimistic_lock(task_id: str, new_status: str):
    """楽観的ロックによる安全な更新"""
    max_retries = 5
    
    for attempt in range(max_retries):
        # 現在のバージョンを取得
        task_doc = await collection.find_one({"_id": task_id})
        current_version = task_doc.get("_version", 1)
        
        # バージョン条件付き更新
        result = await collection.update_one(
            {"_id": task_id, "_version": current_version},
            {
                "$set": {"status": new_status},
                "$inc": {"_version": 1}
            }
        )
        
        if result.modified_count == 1:
            return {"success": True}
        
        # 競合発生時のリトライ
        await asyncio.sleep(0.1 * (2 ** attempt))
    
    return {"error": "Update failed due to high contention"}
```

#### **複数ドキュメントトランザクション**
```python
async def complete_task_and_schedule_next(task_id: str, next_task_data: dict):
    """アトミックなタスク完了と次回スケジューリング"""
    async with await client.start_session() as session:
        async with session.with_transaction():
            # 操作1: 現在タスクの完了
            await work_records.update_one(
                {"_id": task_id},
                {"$set": {"status": "completed"}},
                session=session
            )
            
            # 操作2: 次回タスクの作成
            await auto_tasks.insert_one(
                next_task_data,
                session=session
            )
```

### 4.2 農業コンプライアンス対応

#### **法的記録保持要件**
```javascript
// work_records コレクション v2.0 (コンプライアンス対応)
{
  "_id": ObjectId("..."),
  "_version": 1,  // オプティミスティックロック用
  
  // 基本作業情報
  "work_date": ISODate("2025-07-26"),
  "field_id": ObjectId("..."),
  "worker_id": ObjectId("..."),
  "work_category": "防除",
  
  // USDA/EPA準拠記録
  "compliance_data": {
    "epa_registration_numbers": ["EPA-12345-6"],
    "applicator_certification_id": "CERT-789",
    "total_area_treated": 2.5,  // hectares
    "rei_hours": 12,  // Re-Entry Interval
    "phi_days": 7     // Pre-Harvest Interval
  },
  
  // 使用資材詳細
  "materials_used": [{
    "material_id": ObjectId("..."),
    "material_name": "ダコニール1000",
    "epa_reg_no": "EPA-12345-6",
    "quantity": 500.0,
    "unit": "ml",
    "dilution_ratio": "1:1000",
    "concentration": "40.0%"
  }],
  
  // 法的監査用
  "audit_trail": {
    "created_by": "system",
    "created_at": ISODate("..."),
    "last_modified": ISODate("..."),
    "modification_history": []
  }
}
```

---

## 🔍 第5部: 観測可能性とデバッグ

### 5.1 LangSmithによる可視化

#### **セットアップ**
```bash
export LANGCHAIN_TRACING_V2="true"
export LANGCHAIN_API_KEY="YOUR_LANGSMITH_API_KEY"
export LANGCHAIN_PROJECT="agri-ai-agent-production"
```

#### **トレース分析例**
```
ユーザー: "今日のタスクを教えて。それと、A畑の土壌水分は？"

Supervisor (1回目):
├─ 入力: ユーザーメッセージ
├─ 思考: タスク照会が必要と判断
└─ 出力: Route(next="TaskManagementAgent")

TaskManagementAgent:
├─ 入力: グラフ状態
├─ ツール: TaskLookupTool実行
└─ 出力: 今日のタスクリスト

Supervisor (2回目):
├─ 入力: 更新された状態
├─ 思考: 土壌水分クエリが未解決
└─ 出力: Route(next="FarmDataQueryAgent")

FarmDataQueryAgent:
├─ 入力: さらに更新された状態
├─ ツール: SensorDataTool実行
└─ 出力: A畑の土壌水分データ

Supervisor (3回目):
├─ 入力: 完全な情報を含む状態
├─ 思考: 要求がすべて満たされた
└─ 出力: Route(next="FINISH")
```

### 5.2 メトリクス監視

#### **パフォーマンス指標**
```python
import time
from functools import wraps

def monitor_agent_performance(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.time()
        
        try:
            result = await func(*args, **kwargs)
            
            # 成功メトリクス
            execution_time = time.time() - start_time
            await log_metrics({
                "agent": func.__name__,
                "status": "success",
                "execution_time": execution_time,
                "timestamp": datetime.now()
            })
            
            return result
            
        except Exception as e:
            # エラーメトリクス
            await log_metrics({
                "agent": func.__name__,
                "status": "error",
                "error_type": type(e).__name__,
                "timestamp": datetime.now()
            })
            raise
    
    return wrapper
```

---

## 🚀 第6部: 段階的実装ロードマップ

### Phase 1: 基礎アーキテクチャ (2週間)
- [ ] LangGraph基本構造の構築
- [ ] MongoDBSaver統合
- [ ] LineSupervisor + DataQueryAgent実装
- [ ] 読み取り専用ツール群実装
- [ ] LangSmith統合

### Phase 2: インテリジェント機能 (3週間)
- [ ] AgronomyAdvisorAgent実装
- [ ] PesticideRecommendationTool サブグラフ
- [ ] TaskExecutionAgent (書き込み機能)
- [ ] オプティミスティックロック実装
- [ ] 自己修正ループ実装

### Phase 3: 高度化機能 (4週間)
- [ ] scratchpadコレクション + 反復パターン
- [ ] 非同期アーキテクチャ (Pub/Sub)
- [ ] NotificationAgent実装
- [ ] 複数ドキュメントトランザクション
- [ ] コンプライアンス記録対応

### Phase 4: 本番準備 (2週間)
- [ ] 監視・アラート システム
- [ ] パフォーマンス最適化
- [ ] セキュリティ監査
- [ ] 負荷テスト実施

---

## 📋 成功指標

### 技術指標
- **応答時間**: <3秒 (90%tile)
- **可用性**: 99.9%
- **データ整合性**: 100%
- **エラー率**: <1%

### 業務指標
- **農薬選定時間**: 従来30分 → 0分
- **新人判断迷い時間**: 50%削減
- **コンプライアンス違反**: 0件
- **作業効率**: 30%向上

---

## 🔚 まとめ

本アーキテクチャガイドは、Manusの先進的な設計思想を農業ドメインに特化して応用し、LangGraph + MongoDBによる世界クラスのマルチエージェントシステムを構築するための完全なブループリントです。

### 核心的な成功要因

1. **責務分割**: 専門エージェントによる確実性向上
2. **状態管理**: 永続化による堅牢性確保  
3. **自己修正**: エラーからの学習と回復
4. **コンプライアンス**: 法的要件への完全対応
5. **観測可能性**: LangSmithによる完全な可視化

このアーキテクチャにより、単なる情報検索システムを超えた、農業現場の意思決定プロセスそのものを変革する真のAIパートナーが実現されます。

---

**作成者**: Claude Code  
**統合完了**: 2025-07-26  
**次回更新**: 実装進捗に応じて段階的更新